import configparser, os, shutil
import subprocess
import numpy
import datetime
import pdb
import re
__contact__ = 'Humberto C. Godinez, hgodinez@lanl.gov'

class ensemble(object):

    """
    ensemble class

    This module contains a class for generating an ensemble structure for a
    given program. Some customization might be necessary, specifically for the
    generation of the model parameter input files for the ensemble.

    object variables:
    ----------------------
    config_file          string: ensemble input configuration file
    list                 integer array: list of ensemble members
    Nens                 integer: number of ensemble members
    parameter_file       string: file name for model input parameters
    executable           string: name of executable
    sample_file          string: file name for perturbed parameter names and
                        values
    base_dir             string: prefix for ensemble directory names
    path_ensemble        string: location path for ensemble directory
                                structure
    path_code            string: location path for model input files and other
                                model relevant files
    files                array of strings: file names of all other relevant
                                          model input files

    object methods:
    --------
    read_input           read ensemble input file
    create_directories   creates directory structure for ensembles
    copy_files           copies relevant model input files to each ensemble
                        directory
    generate_parameters  generates the model input file for each ensemble
                        member, where the parameters indicated in the sample
                        file are perturbed
    submit               submit the ensemble jobs (needs customization)

    Example:
    --------

    >>> ens = ensembles.ensemble()
    >>> ens.read_input(config_file='example.dat')

    see 'read_input' for a complete description of the structure and necessary
    information required in 'example.dat'

    >>> ens.create_directories()
    >>> ens.generate_parameters()


    Credits:
    -------
    Authors: Humberto C. Godinez
    Institution: Los Alamos National Laboratory
    Contact: hgodinez@lanl.gov

    """

    # ----------------------------------------------------------------------------
    # read input information
    #
    def read_input(self,config_file=None):
 
       """
 
       Parameters
       ==========
       config_file : string
                     file name of ensemble input configuration file (see below
                     for details and example). The default file is
                     'ensembles.dat' located in the current directory.
 
       Returns
       =======
       object attributes with ensemble options
 
       Description
       ===========
 
       This method reads the ensemble configuration input file, indicated by
       config_file,  to generate the ensemble directory structure and
       corresponding model input files. The ensemble input file uses the
       configuration file parser language which provides a structure similar
       to what you would find on Microsoft Windows INI files. You can use this
       to write Python programs which can be customized by end users easily.
       It contains an 'ensemble' section, which in turns contains the
       following 'options':
 
       members: indicates the ensemble members to be  generated. These are
                expressed as an interval (1-10 or 1:10), as a list
                (1,4,6,18,23), and/or as combinations of these two.
 
       path_code: indicates the path where the base input file is located, as
                  well as where other relevant model configuarations files.
       
       base_parameter: the name of the base parameter file to be used in the
                  ensemble. Some parameter value entries will be modified, as
                  indicated in the sample parameter file (see the LHS-python
                  scripts and instructions)
 
       sample_file: indicates the complete path, as well as the name of the
                    paramter sample file. This file contains the names of the
                    perturbed parameter, as well as the values of the
                    perturbed parameters, to be used in the ensemble. This
                    sample file is generated by latin hypercube sampling
                    python scripts located in LHS-python subdirectory.
 
       path_ensemble: complete path for the location of the ensemble
 
       base_dir: base directory name for each ensemble member. The
                 nomenclature will be composed of the base directory plus the
                 ensemble members being generated, as indicated by the
                 'members' option above. As example, suppose members=1-5 and
                 base_dir=ens, then the ensemble directories are named ens_1,
                 ens_2, ens_3, ens_4, ens_5.
 
       An example ensemble configuation file is the following:
 
       [ensemble]
       members=1-10
       path_code=/u/hgodinez/IMPACT/impact/GITM2
       base_parameter_file=UAM.in
       sample_file=/u/hgodinez/IMPACT/impact/GITM2/GITM.txt
       path_ensemble=/u/hgodinez/IMPACT/GITM_ens
       base_dir=run
 
       Examples
       ========
 
       >>> import ensembles
       >>> ens = ensembles.ensemble()
       >>> ens.read_input(config_file='example.dat')
 
       or use the default configuration file 'ensembles.dat' and do
 
       >>> import ensembles
       >>> ens = ensembles.ensemble()
       >>> ens.read_input()
 
       """
 
       # set up the configparser
       config = configparser.ConfigParser()
       config.add_section("ensemble")
 
       # read the input file
       if (config_file):
           self.config_file = config_file
       else:
           self.config_file = 'ensembles.dat'
           print("using default ensemble input file name ensembles.dat")
       #end
 
       # check that configuration file exists
       fname = open(self.config_file)
 
       config.readfp(fname)
       ensemble = config.get('ensemble','members')
       ensemble = ensemble.split(',')
 
       # determine the list of ensemble to be produced
       list = numpy.array([],dtype=int)
       for c in ensemble:
           n1 = c.find(':')
           n2 = c.find('-')
           if n1 > 0:
               s = c.split(':')
               b1 = int(s[0])
               b2 = int(s[1])
               num = numpy.arange(b1,b2+1)
           elif n2 > 0:
               s = c.split('-')
               b1 = int(s[0])
               b2 = int(s[1])
               num = numpy.arange(b1,b2+1)
           else:
               num = numpy.int(c)
           #end
           list =numpy.append(list,num)
       #end
       self.list = list
 
       # get number of ensemble member, derived from list
       self.Nens = len(self.list)
 
       # get the base directory format name
       self.base_dir = config.get('ensemble','base_dir')
 
       # determine which input file to base upon
       self.parameter_file = config.get('ensemble','base_parameter_file')
 
       # get executable file name
       if (config.has_option('ensemble','executable')):
           self.executable = config.get('ensemble','executable')
       #end
 
       # get sampling file name
       self.sample_file = config.get('ensemble','sample_file')
 
       # read destination path for ensemble
       self.path_ensemble = config.get('ensemble','path_ensemble')
 
       # read the path for code
       self.path_code = config.get('ensemble','path_code')
 
       # read file list
       if (config.has_option('ensemble','files')):
           files = config.get('ensemble','files')
           files = files.split('\n')
           tmp = []
           for fl in files:
               tmp2 = p.split(fl)
               for item in tmp2:
                   tmp.append(item.strip())
               #end
           #end
           self.files = filter(None, tmp)
       #end
 
       # set ensemble path filename
       self.ensemble_path = 'simulationpath.txt'
 
       fname.close()
 
    #end

    # ----------------------------------------------------------------------------
    # create ensemble directories
    # and simulationpath.txt file
    #
    def create_directories(self):
 
        """
         Parameters
         ==========
 
         Returns
         =======
         ensemble directory structure
 
         Description
         ===========
 
         This method creates the ensemble directory struture in the path
         specified by the object variable 'path_ensemble'. If the path
         directory specified by 'path_ensemble' does not exist, it is created
         (as long as the user has writing privileges) The prefix for the
         ensemble directories name is specified by 'base_dir' and the suffix
         by the ensemble 'list' variable. 
 
         Examples
         ========
 
         The following example produces ensemble directories
         ens_1, ens_2, ens_3, ens_4, ens_5 
         by using base_dir=ens and list=[1,2,3,4,5].
 
         >>> import numpy
         >>> import ensembles
         >>> ens = ensembles.ensemble()
         >>> ens.list=numpy.array([1,2,3,4,5])
         >>> ens.path_code='/path/to/code'
         >>> ens.path_ensemble='/path/to/ensemble'
         >>> ens.base_dir='ens'
         >>> ens.paramter_file='parameter.txt'
         >>> ens.create_directories()
 
         Alternatively, specify these options in 'ensembles.dat' (see
         read_input) and do
 
         >>> import ensembles
         >>> ens = ensembles.ensemble()
         >>> ens.read_input()
         >>> ens.create_directories()
 
        """
 
     
        # check that ensemble directory exists, if not, create directory
        if os.access(self.path_ensemble,os.F_OK):
            print('ensemble directory '+self.path_ensemble+' exists')
        else:
            os.mkdir(self.path_ensemble)
            print('ensemble directory '+self.path_ensemble+' created!')
        #end
 
        print(os.getcwd())
 
        fpath = open(self.ensemble_path,'w')
 
        # ensemble loop
        for num in self.list:
 
            print('==========================================================')
            print('ensemble member '+str(num))
  
            # ==============================================
            # DEBUG
            #pdb.set_trace()
            # ==============================================
  
            # check for directories
            dest = self.path_ensemble+'/'+self.base_dir+'_'+str(num)
            if os.access(dest,os.F_OK):
                print(dest+' already exists')
            else:
                # get current path
                curr_path = os.getcwd()
   
                # change to directory where code resides
                os.chdir(self.path_code)
   
                # make run directory
                os.system('make rundir')
   
                # rename run directory and move to ensemble path
                #os.rename(self.path_code+'/run',dest)
                os.system('mv '+self.path_code+'/run '+dest)
   
                # move back to current directory
                os.chdir(curr_path)
  
            fpath.write(dest+'\n')
            #fpath.write("'"+dest+"'\n")
            #fpath.write('"'+dest+'/"'+'\n')
            #fpath.write(self.parameter_file+'\n')
        #end
 
        fpath.close()
 
        return
    #end


    # ----------------------------------------------------------------------------
    # subroutine to create simbolic links
    #
    def copy_files(self):
       """
       Parameters
       ==========
 
       Returns
       =======
       appropriate model input files for each ensemble member
 
       Description
       ===========
       This method makes a copy of the appropriate model input files in eadh of
       the ensemble directories. The files must be specified in the 'files'
       variable, which is an array of string (model input file names). The files
       must be contained in the path specified by the 'path_code' variable.
 
       Examples
       ========
 
       The following example copies parameters.in, ic.in, and bc.in into each
       of the ensemble directories ens_1, ens_2, ens_3, ens_4, ens_5. The
       ensemble directories must already exits.
 
       >>> import numpy
       >>> import ensembles
       >>> ens = ensembles.ensemble()
       >>> ens.list=numpy.array([1,2,3,4,5])
       >>> ens.path_code='.'
       >>> ens.path_ensemble='.'
       >>> ens.base_dir='ens'
       >>> ens.files=['parameters.in', 'ic.in', 'bc.in']
       >>> ens.copy_files()
 
       Alternatively, specify these options in 'ensembles.dat' (see
       read_input) and do
 
       >>> import ensembles
       >>> ens = ensembles.ensemble()
       >>> ens.read_input()
       >>> ens.copy_files()
 
       """
 
       # check that source files exist
       for ifile in self.files:
           source_file = self.path_code+'/'+ifile
           if not os.access(source_file,os.F_OK):
               raise RuntimeError('file '+source_file+' does not exist')
           #end
       #end
 
       # ensemble directory loop
       for num in self.list:
 
           # dest directory
           dest = self.path_ensemble+'/'+self.base_dir+'_'+str(num)
  
           # file loop
           for ifile in self.files:
  
               # identify source file
               source_file = self.path_code+'/'+ifile
   
               # check for file
               dest_file = dest+'/'+ifile
               if os.access(dest_file,os.F_OK):
                   shutil.copy(source_file,dest)
               else:
                   shutil.copy(source_file,dest)

    # ----------------------------------------------------------------------------
    # subroutine to create parameters
    #
    def generate_parameters(self):
        """
        Parameters
        ==========
 
        Returns
        =======
        model parameter input files for ensemble
 
        Description
        ===========
        This method generates the appropriate model parameter input file for
        each ensemble member, using the model parameter input file given in
        'parameter_file' as a base file, and modifying the paramteres from the
        sample file given in 'sample_file'. The parameter sample file will provide
        the name and value of the various paramteres to be perturbed. This
        procedure is highly customizable. Each perturbed model parameter input
        file will then be placed in the appropriate ensemble directory,
        indicated by the 'path_ensemble' and 'list' variables.
 
 
        Examples
        ========
 
        The following example uses param.in for the base parameter file, and the
        sample.txt (above example) for the sample paramter values. It places
        each paramete file in the corresponding 5 ensemble members directories
        
        >>> import numpy
        >>> import ensembles
        >>> ens = ensembles.ensemble()
        >>> ens.list=numpy.array([1,2,3,4,5])
        >>> ens.path_code='../'
        >>> ens.path_ensemble='.'
        >>> ens.base_parameter_file=param.in
        >>> ens.sample_file=sample.txt
        >>> ens.base_dir='ens'
        >>> ens.create_directories()
        >>> ens.generate_parameters()
  
        Alternatively, specify these options in 'ensembles.dat' (see
        read_input) and do
 
        >>> import ensembles
        >>> ens = ensembles.ensemble()
        >>> ens.read_input()
        >>> ens.create_directories()
        >>> ens.generate_parameters()
 
        """
 
        import os
        import numpy
        import pdb
 
        # parameter filename and path
        #param_filename = self.path_code+'/'+self.parameter_file
 
        # open parameter file, read file line by line
        # and store it in an array, close file
        #fparam = open(param_filename,'r')
        fparam = open(self.parameter_file,'r')
        parameters = []
        for line in fparam:
            parameters.append(line)
        fparam.close()
 
        # The sample file contains the perturbed parameter values.
        # This file will contain the values for F10.7 and 
        # the bias introduced into the perturbation.
 
        # open sample file
        fs = open(self.sample_file)
 
        # read parameter names
        parameter_names = fs.readline()
        parameter_names = parameter_names.strip('\n').strip().split()
 
        # read parameter line within the name group
        parameter_lines = fs.readline()
        parameter_lines = parameter_lines.strip('\n').strip().split()
 
        # read samples from sample file, as strings
        #sample = numpy.array([],dtype=float)
        sample = numpy.array([],dtype='|S1')
        rows = 0
        for line in fs:
            for n in line.strip(' ').strip('\n').split():
                #sample = numpy.append(sample,float(n))
                sample = numpy.append(sample,n)
            #end
            rows = rows+1
            columns = len(line.strip(' ').strip('\n').split())
        #end
        sample = sample.reshape(rows,columns)
        fs.close()
 
        # number of parameters to modify
        count = len(parameter_names)

        # ==============================================
        # DEBUG
        #pdb.set_trace()
        #
        # need to get exact match, maybe use regular expressions:
        #
        # import re
        # s = '98787This is correct'
        # for words in ['This is correct', 'This', 'is', 'correct']:
        #     if re.search(r'\b' + words + r'\b', s):
        #         print('{0} found'.format(words))
        #
        # this snippet from the stackoverflow:
        # https://stackoverflow.com/questions/18632491/how-do-i-check-for-an-exact-word-in-a-string-in-python
        #
        # ==============================================
 
        # Initialize the parameter_fileline array. 
        # This array indicates the line number in the model parameter inout file
        # where the parameter name to be perturbed is located.  When the
        # parameter in parameter_names is not found in the model input paramtere
        # file, the parameter_fileline array takes a value of -1.
        parameter_fileline = -1*numpy.ones((count),dtype=int)
 
        # identify location of parameters name
        # in parameters file
        for icount, name in enumerate(parameter_names):
            for count, line in enumerate(parameters):

                # check that line is not empty (blank line)
                if (len(line.strip().split())>0): 

                    #print(line)
                    #print(line.strip().split())
                    #pdb.set_trace()

                    # strip line and get first string
                    line2 = line.strip().split()[0]

                    # check if string and parameter name are same length
                    # and check if match
                    if ((len(line2) == len(name)) and (line2.find(name) >= 0)):
                        parameter_fileline[icount]=count

                    # check to see if match

###                print(line)
###                print(line.strip().split())
###
###                # check that line is not empty (blank line)
###                if (len(line.strip().split())>0):
###
###                    # removes all special characters from the strings
###                    line2 = re.sub('[^A-Za-z0-9]+','',line)
###                    name2 = re.sub('[^A-Za-z0-9]+','',name)
###
###                    pdb.set_trace()
###
###                    # search exact string
###                    match = re.search(r'^'+name2+'$',line2)
###
###                    # if there is an exact match then re-verify
###                    if (match):
###
###                        # do match on exact phrase
###                        n = line.find(name)
###
###                        # check that there is a match
###                        if n >= 0:
###                           parameter_fileline[icount]=count
###                        #end

                #n = line.find(name)
                #if n >= 0:
                #   parameter_fileline[icount]=count
                #end
            #end
        #end
 
        # define split criterion using regular expressions
        p = re.compile('[ =,;\t]+')
 
        # generate the parameters files
        for num in self.list:
            for icount, name in enumerate(parameter_names):
                if (parameter_fileline[icount] >= 0):
                    line = parameters[(parameter_fileline[icount]+
                          int(parameter_lines[icount]))]
                    #line = line.split()
                    #strline = ' '.join(line[1:])
                    #strline = str(sample[num-1,icount])+'\t\t'+strline+'\n'

                    #pdb.set_trace()
    
                    # split line using compiled regular expression
                    entries = p.split(line)
                    #entries = filter(None,entries)
    
                    # get length of line entry where we will make replacement
                    #n = line.find(entries[0])
                    #strline =  line[:n]+sample[num-1,icount]+'\n'
                    strline = line.replace(entries[0],sample[num-1,icount])
    
                    # assing to correct location
                    parameters[(parameter_fileline[icount]+
                          int(parameter_lines[icount]))] = strline
            #end
  
            # parameter destination directory
            dest = self.path_ensemble+'/'+self.base_dir+'_'+str(num)
  
            # check that destination directory exists
            if not os.access(dest,os.F_OK):
                raise RuntimeError("directory "+dest+" does not exist")
  
            # write new parameters file
            fg = open(dest+'/'+self.parameter_file,'w')
            for line in parameters:
               fg.write(line)
            fg.close()
            print(" parameters for "+str(num)+" complete")
        #end
 
        return 0
    #end

    # ----------------------------------------------------------------------------
    # submmit jobs
    #
    def submit(command,script):
       """
       Parameters
       ==========
 
       Returns
       =======
 
       Description
       ===========
       Submit job with 'command' and alternative inputs 'script'
 
       Examples
       ========
 
       >>> import ensembles
       >>> ens = ensembles.ensemble()
       >>> ens.submit(command='./GITM.exe',script='')
 
       """
 
       if os.access(script,os.F_OK):
           os.system(command+" "+script)
           print(command+" "+script)
       else:
           print('directory '+script+' does not exist')
       #end
 
       return   

    # ----------------------------------------------------------------------------
    # simulation start, stop time
    #
    def simulation_time(self,startdate,enddate,restart=False):
       """
       Parameters
       ==========
       startdate : datetime object
                   start time of ensemble simulation
       enddate : datetime object
                 end time of ensemble simulation
 
       Returns
       =======
 
       Description
       ===========
       Specifies the start and end dates for the ensemble simulation. This
       subroutine should be called AFTER the ensemble input is read and BEFORE
       the generation of the parameter generation.
 
       Examples
       ========
 
       >>> import ensembles
       >>> ens = ensembles.ensemble()
       >>> ens.read_input()
       >>> import datetime
       >>> start = datetime.datetime(2009,10,22)
       >>> end = datetime.datetime(2009,10,27)
       >>> ens.simulation_time(start,end)
       >>> ens.generate_parameters()
 
       """
 
       # ------------------------------
       # assing dates
       # ------------------------------
 
       # check for consistency
       if (startdate > enddate):
           raise ValueError('start date ',startdate,' is older than end date',enddate)
       #end
 
       # assing start date
       self.startdate = startdate
 
       # assing end date
       self.enddate = enddate
 
       # ------------------------------
       # modify appropriate input file
       # ------------------------------
 
       # model input filename and path
       fparam = open(self.parameter_file,'r')
       lines = fparam.readlines()
       fparam.close()
 
       # CUSTOMIZATION
       for iline,line in enumerate(lines):
           # -------------------
           # find appripriate input argument
           # -------------------
           n1 = line.find('#TIMESTART')
           n2 = line.find('#TIMEEND')
 
           # -------------------
           # set start or end dates
           # -------------------
           if (n1 >= 0):
               date = startdate
           #end
           if (n2 >= 0):
               date = enddate
           #end
           if (n1 >= 0 or n2 >= 0):
               # set year
               lines[iline+1] = date.strftime('%Y')+'\t\tyear\n'
               # set month
               lines[iline+2] = date.strftime('%m')+'\t\tmonth\n'
               # set day
               lines[iline+3] = date.strftime('%d')+'\t\tday\n'
               # set hour
               lines[iline+4] = date.strftime('%H')+'\t\thour\n'
               # set minute
               lines[iline+5] = date.strftime('%M')+'\t\tminute\n'
               # set second
               lines[iline+6] = date.strftime('%S')+'\t\tsecond\n'
           #end
       #end
 
       # modify input file if restarting from previous solution
       for iline,line in enumerate(lines):
           n = line.find('#RESTART')
           if ( n>=0 ):
               if (restart):
                   lines[iline+1] = 'T\n'
               else:
                   lines[iline+1] = 'F\n'
               #end
           #end
       #end
 
       # write new model input file
       fparam = open(self.parameter_file,'w')
       for line in lines:
           fparam.write(line)
       #end
       fparam.close()


    # ----------------------------------------------------------------------------
    # ensemble parallel simulation
    #
 
    def ensemble_simulation(self,np=None):
 
        # -------------------
        # get simulation path for each ensemble member
        # -------------------
 
        #fpath = open(self.path_code+'/simulationpath.txt')
        #paths = fpath.readlines()
        #fpath.close()
 
        # -------------------
        # modify the BASH script file accordingly
        # -------------------
 
        #fbash = open('ensemble.sh')
        #bash_lines = fbash.readlines()
        #fbash.close()
 
        # -------------------
        # rewrite the ensemble path files to remove '
        # -------------------
 
        # open file
        fpath = open(self.ensemble_path,'r')
        lines = fpath.readlines()
        fpath.close()
 
        # open file for writing
        fpath = open(self.ensemble_path,'w')
 
        # writing loop
        for line in lines:
            tmp = line.strip('\n').strip().strip("'")
            fpath.write(tmp+'\n')
        #end
        fpath.close()
 
        # -------------------
        # submit ensemble in parallel
        # -------------------
 
        if np:
            # mpirun command
            mpirun = 'mpirun -np '+str(np)+' ./ensemble.sh'
        else:
            # mpirun command
            mpirun = 'mpirun -np '+str(self.Nens)+' ./ensemble.sh'
 
        print(mpirun)
 
        # submit enseble parallel run
        os.system(mpirun)

    # ----------------------------------------------------------------------------
    # ensemble parallel simulation using Multiple Program Multiple Data (MPMD) approach
    #
     
    def ensemble_simulation_MPMD(self,Np,hostname,executable,inputs=[],ensemble_index_list=[]):
 
        """
        Script to run multiple process with multiple data with MPI.
        Specifically designed for ensemble simulation.
 
        Parameters
        ==========
        Np : integer
             set the number of processors to use
             per ensemble member
 
        hostname : string
                   sets the name of the host 
                   to execute the MPI runs
 
        executable : string
                    name of executable for simulation
 
        inputs : list of strings (optional)
                    if provided, gives a name of input arguments for the
                    executable
 
        ensemble_index_list : numpy array (optional)
                             if provided, gives the index list
                             of ensemble members to simulate
 
        Returns
        =======
        creates ensemble.sh bash script to be executed in the
        hostname
 
        Description
        ===========
        This method creates and executes an ensemble.sh bash script
        file to simulate each ensemble member in parallel, where
        each individual ensemble simulation needs to run with MPI as
        well.
 
        Examples
        ========
 
        >>> ens.ensemble_simulation_MPMD(Np=4,hostname='serrano2',executable='ram-scb.exe')
 
        """
        # verify that the input is list of numpy array
        list_flag = isinstance(inputs,list)
        narray_flag = isinstance(inputs,numpy.ndarray)
        if not (narray_flag or list_flag):
            raise ValueError("inputs must be list or numpy array")
 
        # get number of processors for each ensemble simulation
        self.Np = Np
 
        # -------------------
        # rewrite the ensemble path files to remove '
        # -------------------
 
        # open file
        fpath = open(self.ensemble_path,'r')
        paths = fpath.readlines()
        fpath.close()
 
        # open file for writing
        fpath = open(self.ensemble_path,'w')
 
        # writing loop
        for line in paths:
            tmp = line.strip('\n').strip().strip("'")
            fpath.write(tmp+'\n')
        #end
        fpath.close()
 
        # -------------------
        # modify appfile for mpirun
        # -------------------
 
        # determine sub-list of paths if ensemble index list is
        # provided
        if (numpy.isscalar(ensemble_index_list)):
            ensemble_index_list = numpy.array([ensemble_index_list],dtype=int)
        #end
        if (len(ensemble_index_list) > 0):
            paths = numpy.array(paths)
            paths = paths[ensemble_index_list]
        #end
 
        # open ensemble.sh file for writing
        fh = open('ensemble.sh','w')
        fh.write('#!/bin/bash')
        fh.write('\n')
 
        # write the mpirun commands
        for iline,line in enumerate(paths):
            fh.write('\n')
            fh.write('# ensemble '+str(iline)+'\n')
            fh.write('mpirun -H '+hostname+' -np '+str(self.Np)+' -wdir '+line.strip()
                         +' ./'+executable+' '+' '.join(inputs)+' > '+line.strip()+'/out &')
        #end
 
        # close file 
        fh.close()
 
        # change permissions to execute file
        os.system('chmod a+rx ensemble.sh')
 
        # -------------------
        # submit ensemble in parallel
        # -------------------
 
        run_simulation = './ensemble.sh'
 
        print(run_simulation)
 
        # submit enseble parallel run
        os.system(run_simulation)

    # ----------------------------------------------------------------------------
    # create a hosts names file
    #

    def hostfile(self,hostfile):

        """
        Script to create a hostfile.

        Parameters
        ==========
        hostfile : string
                  provides the name of the hostfile to write names of
                  the multiple hosts available for ensemble runs

        Returns
        =======
        creates a hostilfe for mpirun

        Description
        ===========
        This method creates a hostfile with the names of the hosts available to
        simulate the ensemble in parallel, using MPI.

        Examples
        ========

        >>> import ensemble
        >>> ens = ensemble.ensemble()
        >>> ens.hostfile(hostfile='hosts.dat')

        """

        # assign hostfile name
        self.hostfile = hostfile

        # get hosts from environment variable
        hosts = os.getenv('SLURM_NODELIST')

        # split host name (prefix) and compressed list of host
        hosts_prefix, hosts_list = hosts.strip(']').strip().split('[')
        hosts_list = hosts_list.split(',')

        # determine the list of hosts
        list = numpy.array([],dtype=int)
        for c in hosts_list:
            n1 = c.find('-')
            if n1 > 0:
                s = c.split('-')
                b1 = int(s[0])
                b2 = int(s[1])
                num = numpy.arange(b1,b2+1)
            else:
                num = numpy.int(c)
            #end
            list = numpy.append(list,num)
        #end

        # put list hosts in the correct format
        hosts_list=[]
        for num in list:
            hosts_list.append(str(num).zfill(3))

        # write hosts to file
        fh = open(hostfile,'w')
        for h in hosts_list:
            fh.write(hosts_prefix+h+'\n')
        fh.close()

    # ----------------------------------------------------------------------------
    # ensemble parallel simulation using Multiple Program Multiple Data (MPMD) for HPC
    #
    
    def MPMD(self,Np,hostfile,executable,inputs=[],ensemble_index_list=[]):

        """
        Script to run multiple process with multiple data with MPI.
        Specifically designed for ensemble simulation.

        Parameters
        ==========
        Np : integer
            set the number of processors to use
            per ensemble member

        hostfile : string
                  provides the name of the hostfile which containsthe names of
                  the multiple hosts available for ensemble runs

        executable : string
                    name of executable for simulation

        inputs : array of strings
                    name of input arguments for the executable

        ensemble_index_list : numpy array
                             if provided, gives the index list
                             of ensemble members to simulate

        Returns
        =======
        submits a series of mpirun command to run the ensemble in parallel

        Description
        ===========
        This method creates and submits a series of mpirun commands to simulate
        each ensemble member in parallel using MPI.

        Examples
        ========

        >>> import ensemble
        >>> ens = ensemble.ensemble()
        >>> ens.hostfile(hostfile='hosts.dat')
        >>> ens.MPMD(Np=16,hostfile='hosts.dat',executable='GITM.exe')

        """
        # verify that the input is list of numpy array
        list_flag = isinstance(inputs,list)
        narray_flag = isinstance(inputs,numpy.ndarray)
        if not (narray_flag or list_flag):
            raise ValueError("inputs must be list or numpy array")

        # get number of processors for each ensemble simulation
        self.Np = Np

        # -------------------
        # get names of the hosts
        # -------------------
        fh = open(hostfile,'r')
        lines = fh.readlines()
        fh.close()

        hosts = []
        for iline,line in enumerate(lines):
            hosts.append(line.strip('\n').strip())

        # -------------------
        # rewrite the ensemble path files to remove '
        # -------------------

        # open file
        fpath = open(self.ensemble_path,'r')
        paths = fpath.readlines()
        fpath.close()

        # open file for writing
        fpath = open(self.ensemble_path,'w')

        # writing loop
        for line in paths:
            tmp = line.strip('\n').strip().strip("'")
            fpath.write(tmp+'\n')
        #end
        fpath.close()

        # -------------------
        # create appropriate mpirun command
        # -------------------

        # determine sub-list of paths if ensemble index list is
        # provided
        if (numpy.isscalar(ensemble_index_list)):
            ensemble_index_list = numpy.array([ensemble_index_list],dtype=int)
        #end
        if (len(ensemble_index_list) > 0):
            paths = numpy.array(paths)
            paths = paths[ensemble_index_list]
        #end
 
        mpicommand = []

        # write the mpirun commands
        for iline,line in enumerate(paths):
            command = ('mpirun'+' -np '+str(self.Np)+
                    ' --mca mpi_paffinity_alone 0'+' -H '+hosts[iline]+
                    ' -wdir '+line.strip()+' ./'+executable+' '+' '.join(inputs)+
                    ' > '+line.strip()+'/out &')
            mpicommand.append(command)
        #end

        # -------------------
        # submit ensemble in parallel
        # -------------------

        # submit enseble parallel run
        for command in mpicommand:
            print(command)
            os.system(command)
